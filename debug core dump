	关于程序core dump的调试方法简述：
	
	首先，在程序不正常退出时，内核会在当前工作目录下生成一个core文件(是一个内存映像，同时加上调试信息)。使用gdb来查看core文件，可以指示出导致程序出错的代码所在文件和行数。这个能给debug带来极大方便。

	查看core dump位置方法:"gdb ./app core".
	
	故，我们需要gdb，可执行文件app，以及core文件。下面将根据这3个需求，依次得到它们;

一、
	1,得到gdb;
		其实这个是最简单的，Linux PC上gdb不用说了。Android的是~/opt/android-ndk-r7/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/arm-linux-androideabi-gdb(其中~/opt/，与个人设置有关;android-ndk-r7与编译器版本有关,貌似android-ndk-r4没有toolchains目录，不知是否可以用gdbserver调试程序，当然这就不在本文档的讨论范围之内了).
	2,得到可执行文件app
		由于要使用gdb，所以app必须是"not stripped".Linux PC上"gcc hello.c"编译出来的a.out默认就是"not stripped".Android工程中jni目录下，我们使用"ndk-build"默认是"stripped"的。因此需要更改编译脚本：在~/opt/android-ndk-r7/build/core/中打开default-build-commands.mk文件，将"cmd-strip = $(PRIVATE_STRIP) --strip-unneeded $(call host-path,$1)"这一行注释掉.这一行就是做的"strip"操作。再用"ndk-build"编译就是"not stripped"的了。
	3,得到core文件（程序异常退出时，当前目录已经有core文件了，当然，此步可以跳过）
		Linux PC和Android，命令"ulimit -c"查看生成的core文件的大小限制。一般输出是"0",即不允许生成core文件，命令"ulimit -c unlimited"将其设置成无限制。再次运行程序时，就会生成core文件了。此外"ulimit -a"可以查看所有设置。另外一个重要参数是core文件的路径,“cat /proc/sys/kernel/core_pattern”输出core文件的路径，当然也可以修改路径，例如“echo core > /proc/sys/kernel/core_pattern”将其保存在当前路径下.
	4,到此仅需运行"gdb ./app core"(Linux PC)或android : "~/opt/android-ndk-r7/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/arm-linux-androideabi-gdb ./app core",就可以看到程序出错的位置。如果不够详细，用"bt"命令，将会列出函数调用关系。下面是一个实际例子：

hat@SIGMA:~/sigma/process/libs/armeabi$ ~/opt/android-ndk-r7/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/arm-linux-androideabi-gdb ./testcore core 
GNU gdb 6.6
Copyright (C) 2006 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "--host=x86_64-linux-gnu --target=arm-elf-linux"...
Error while mapping shared library sections:
/system/bin/linker: No such file or directory.
Error while mapping shared library sections:
libc.so: Success.
Error while mapping shared library sections:
libstdc++.so: Success.
Error while mapping shared library sections:
libm.so: Success.
Symbol file not found for /system/bin/linker
Symbol file not found for libc.so
Symbol file not found for libstdc++.so
Symbol file not found for libm.so

warning: Unable to find dynamic linker breakpoint function.
GDB will be unable to debug shared library initializers
and track explicitly loaded dynamic code.
Core was generated by `./testcore'.
Program terminated with signal 11, Segmentation fault.
$0  0x00008592 in core_test (p=0x9ac0 "test") at /home/hat/sigma/process/jni/process.c:8
8	        p[0] = 'T';
(gdb) bt
$0  0x00008592 in core_test (p=0x9ac0 "test") at /home/hat/sigma/process/jni/process.c:8
$1  0x000085ae in main (argc=<value optimized out>, argv=<value optimized out>) at /home/hat/sigma/process/jni/process.c:14
(gdb) l 1
1	#include <stdio.h>
2	
3	/*core_dump_test.c*/
4	const char *str = "test";
5	
6	void core_test(char *p)
7	{
8	        p[0] = 'T';
9	}
10	
(gdb) 
11	int main(int argc, const char *argv[])
12	{
13	        printf("hello\n");
14	        core_test(str);
15	        return 0;
16	}
(gdb) q
hat@SIGMA:~/sigma/process/libs/armeabi$ 

